<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Соник с Мячом</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #mobileControls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
        }
        .controlBtn {
            display: inline-block;
            width: 80px;
            height: 80px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 50%;
            margin: 0 20px;
            line-height: 80px;
            font-size: 24px;
            user-select: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="mobileControls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="jumpBtn" class="controlBtn">↑</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script>
        window.addEventListener('DOMContentLoaded', function() {
    // Получаем canvas и создаем движок
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    
    // Определяем, используется ли мобильное устройство
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Устанавливаем элементы управления для мобильных устройств
    const mobileControls = document.getElementById('mobileControls');
    mobileControls.style.display = isMobile ? 'block' : 'none';
    
    // Создаем функцию для создания сцены
    const createScene = function() {
        const scene = new BABYLON.Scene(engine);
        
        // Установка гравитации и коллизий
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
        
        // Создаем камеру
        const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 5, 10), scene);
        camera.radius = 15; // Расстояние от целевого объекта
        camera.heightOffset = 4; // Высота над целевым объектом
        camera.rotationOffset = 180; // Угол обзора
        camera.cameraAcceleration = 0.05; // Плавность следования
        camera.maxCameraSpeed = 10; // Максимальная скорость камеры
        
        // Создаем свет
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;
        
        // Создаем оранжевый мяч (игрок)
        const ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 2}, scene);
        const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
        ballMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
        ball.material = ballMaterial;
        ball.position.y = 2;
        
        // Добавляем физическое тело к мячу
        ball.physicsImpostor = new BABYLON.PhysicsImpostor(
            ball, 
            BABYLON.PhysicsImpostor.SphereImpostor, 
            { mass: 1, restitution: 0.5, friction: 0.1 }, 
            scene
        );
        
        // Настраиваем камеру, чтобы следовать за мячом
        camera.lockedTarget = ball;
        
        // Создаем массив для хранения рельсов
        const rails = [];
        
        // Функция для создания рельса
        const createRail = function(posX, posY, posZ, width, height, length) {
            const rail = BABYLON.MeshBuilder.CreateBox("rail", {
                width: width,
                height: height,
                depth: length
            }, scene);
            
            const railMaterial = new BABYLON.StandardMaterial("railMaterial", scene);
            railMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            rail.material = railMaterial;
            
            rail.position = new BABYLON.Vector3(posX, posY, posZ);
            
            // Добавляем физическое тело к рельсу (неподвижное)
            rail.physicsImpostor = new BABYLON.PhysicsImpostor(
                rail, 
                BABYLON.PhysicsImpostor.BoxImpostor, 
                { mass: 0, restitution: 0.9 }, 
                scene
            );
            
            rails.push(rail);
            return rail;
        };
        
        // Создаем уровень из рельсов с промежутками
        createRail(0, 0, 0, 4, 1, 15);            // Начальный рельс
        createRail(0, 0, -20, 4, 1, 10);          // Рельс после первого промежутка
        createRail(5, 0, -35, 4, 1, 10);          // Рельс с поворотом вправо
        createRail(0, 0, -50, 4, 1, 10);          // Рельс с поворотом влево
        createRail(0, 0, -65, 6, 1, 10);          // Финальный рельс
        
        // Переменные для управления
        let forwardSpeed = -0.25;  // Скорость вперёд (отрицательная по Z)
        let isJumping = false;
        let horizontalMovement = 0;
        
        // Обработка клавиш для ПК
        const keyDown = (evt) => {
            if (evt.keyCode === 32) { // Пробел
                jump();
            } else if (evt.keyCode === 37) { // Стрелка влево
                horizontalMovement = -0.2;
            } else if (evt.keyCode === 39) { // Стрелка вправо
                horizontalMovement = 0.2;
            }
        };
        
        const keyUp = (evt) => {
            if (evt.keyCode === 37 || evt.keyCode === 39) {
                horizontalMovement = 0;
            }
        };
        
        // Функция прыжка
        const jump = function() {
            // Проверяем, что мяч на земле (не в прыжке)
            const raycast = new BABYLON.Ray(ball.position, new BABYLON.Vector3(0, -1, 0), 1.5);
            const hit = scene.pickWithRay(raycast);
            
            if (hit.hit && !isJumping) {
                isJumping = true;
                ball.physicsImpostor.applyImpulse(
                    new BABYLON.Vector3(0, 8, 0), 
                    ball.getAbsolutePosition()
                );
                
                setTimeout(() => { isJumping = false; }, 1000);
            }
        };
        
        // Настройка обработчиков для ПК
        window.addEventListener("keydown", keyDown);
        window.addEventListener("keyup", keyUp);
        
        // Настройка сенсорных элементов управления для мобильных устройств
        if (isMobile) {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const jumpBtn = document.getElementById('jumpBtn');
            
            // Функции для сенсорного управления
            let isTouchingLeft = false;
            let isTouchingRight = false;
            
            leftBtn.addEventListener('touchstart', function() {
                isTouchingLeft = true;
                horizontalMovement = -0.2;
            });
            
            leftBtn.addEventListener('touchend', function() {
                isTouchingLeft = false;
                if (!isTouchingRight) horizontalMovement = 0;
            });
            
            rightBtn.addEventListener('touchstart', function() {
                isTouchingRight = true;
                horizontalMovement = 0.2;
            });
            
            rightBtn.addEventListener('touchend', function() {
                isTouchingRight = false;
                if (!isTouchingLeft) horizontalMovement = 0;
            });
            
            jumpBtn.addEventListener('touchstart', jump);
            
            // Также поддержка свайпов для управления
            let touchStartX = 0;
            
            canvas.addEventListener('touchstart', function(e) {
                touchStartX = e.touches[0].clientX;
            }, false);
            
            canvas.addEventListener('touchmove', function(e) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (Math.abs(diff) > 10) {
                    horizontalMovement = diff > 0 ? 0.2 : -0.2;
                }
            }, false);
            
            canvas.addEventListener('touchend', function() {
                horizontalMovement = 0;
            }, false);
        }
        
        // Обновление игры на каждом кадре
        scene.registerBeforeRender(function() {
            // Движение мяча вперед автоматически
            ball.physicsImpostor.setLinearVelocity(
                new BABYLON.Vector3(
                    horizontalMovement * 10, 
                    ball.physicsImpostor.getLinearVelocity().y, 
                    forwardSpeed * 20
                )
            );
            
            // Проверка падения в пропасть
            if (ball.position.y < -10) {
                ball.position = new BABYLON.Vector3(0, 5, 0);
                ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
            }
        });
        
        return scene;
    };
    
    // Создаем сцену
    const scene = createScene();
    
    // Запускаем рендеринг
    engine.runRenderLoop(function() {
        scene.render();
    });
    
    // Обработка изменения размера окна
    window.addEventListener('resize', function() {
        engine.resize();
    });
});

    </script>
</body>
</html>
