<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Соник с Мячом</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            position: absolute;
            top: 0;
            left: 0;
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #87CEEB;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #errorMessage {
            position: absolute;
            width: 80%;
            top: 10px;
            left: 10%;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 30;
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 10;
            padding: 10px;
            box-sizing: border-box;
            display: none; /* Скрываем по умолчанию */
        }
        .controlBtn {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, background-color 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .controlBtn.active {
            background-color: rgba(255, 165, 0, 0.9);
            transform: scale(0.95);
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">Загрузка игры...</div>
    <div id="errorMessage"></div>
    <div id="scoreDisplay">Счет: 0</div>
    <canvas id="renderCanvas"></canvas>
    <div id="mobileControls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="jumpBtn" class="controlBtn">↑</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script>
        // Отображение ошибок
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerText = message;
            errorDiv.style.display = 'block';
            document.getElementById('loadingScreen').style.display = 'none';
        }

        // Главная функция запуска игры
        window.addEventListener('DOMContentLoaded', function() {
            try {
                // Получаем canvas и создаем движок
                const canvas = document.getElementById('renderCanvas');
                const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
                
                // Определяем, используется ли мобильное устройство
                const isMobile = ('ontouchstart' in window) || 
                                (navigator.maxTouchPoints > 0) || 
                                (navigator.msMaxTouchPoints > 0) ||
                                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Устанавливаем элементы управления для мобильных устройств
                const mobileControls = document.getElementById('mobileControls');
                mobileControls.style.display = isMobile ? 'flex' : 'none';
                
                console.log("Устройство определено как: " + (isMobile ? "мобильное" : "настольное"));
                
                // Счетчик очков
                let score = 0;
                
                // Создаем сцену
                const createScene = function() {
                    const scene = new BABYLON.Scene(engine);
                    scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1.0); // Небесно-голубой фон
                    
                    // Установка физики с уменьшенной гравитацией для лучших прыжков
                    const gravityVector = new BABYLON.Vector3(0, -8.0, 0); // Уменьшенная гравитация
                    const physicsPlugin = new BABYLON.CannonJSPlugin();
                    scene.enablePhysics(gravityVector, physicsPlugin);
                    
                    // Создаем простую камеру
                    const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 5, 10), scene);
                    camera.setTarget(new BABYLON.Vector3(0, 0, 0));
                    
                    // Создаем свет
                    const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
                    light1.intensity = 0.7;
                    
                    // Направленный свет для лучших теней
                    const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(0, -1, 1), scene);
                    light2.intensity = 0.5;
                    
                    // Создаем оранжевый мяч (игрок)
                    const ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 2, segments: 16}, scene);
                    const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
                    ballMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                    ballMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                    ballMaterial.specularPower = 32;
                    ball.material = ballMaterial;
                    ball.position.y = 4; // Поднимаем мяч выше для начала игры
                    
                    // Добавляем физическое тело к мячу
                    ball.physicsImpostor = new BABYLON.PhysicsImpostor(
                        ball, 
                        BABYLON.PhysicsImpostor.SphereImpostor, 
                        { mass: 1, restitution: 0.5, friction: 0.1 }, 
                        scene
                    );
                    
                    // Массив для хранения всех объектов платформ
                    const rails = [];
                    
                    // Функция для создания рельса
                    const createRail = function(posX, posY, posZ, width, height, length) {
                        const rail = BABYLON.MeshBuilder.CreateBox("rail", {
                            width: width,
                            height: height,
                            depth: length
                        }, scene);
                        
                        const railMaterial = new BABYLON.StandardMaterial("railMaterial", scene);
                        railMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                        rail.material = railMaterial;
                        
                        rail.position = new BABYLON.Vector3(posX, posY, posZ);
                        
                        // Добавляем физическое тело к рельсу (неподвижное)
                        rail.physicsImpostor = new BABYLON.PhysicsImpostor(
                            rail, 
                            BABYLON.PhysicsImpostor.BoxImpostor, 
                            { mass: 0, restitution: 0.9 }, 
                            scene
                        );
                        
                        rails.push({
                            mesh: rail,
                            position: new BABYLON.Vector3(posX, posY, posZ),
                            size: new BABYLON.Vector3(width, height, length)
                        });
                        
                        return rail;
                    };
                    
                    // Создаем уровень из рельсов с промежутками
                    // Начальный рельс
                    createRail(0, 0, 0, 4, 1, 15);
                    
                    // Рельс после первого промежутка
                    // Промежуток уменьшен для лучшей играбельности
                    createRail(0, 0, -17, 4, 1, 10);
                    
                    // Рельс с поворотом вправо
                    createRail(5, 0, -30, 4, 1, 10);
                    
                    // Рельс с поворотом влево
                    createRail(0, 0, -45, 4, 1, 10);
                    
                    // Финальный рельс
                    createRail(0, 0, -60, 6, 1, 10);
                    
                    // Добавляем кольца для сбора (как в оригинальном Сонике)
                    const rings = [];
                    
                    // Функция для создания кольца
                    const createRing = function(posX, posY, posZ) {
                        const ring = BABYLON.MeshBuilder.CreateTorus("ring", {
                            diameter: 1,
                            thickness: 0.2,
                            tessellation: 16
                        }, scene);
                        
                        const ringMaterial = new BABYLON.StandardMaterial("ringMaterial", scene);
                        ringMaterial.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
                        ringMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.4, 0);
                        ring.material = ringMaterial;
                        
                        ring.position = new BABYLON.Vector3(posX, posY, posZ);
                        ring.rotation.x = Math.PI/2; // Поворачиваем кольцо вертикально
                        
                        rings.push(ring);
                        return ring;
                    };
                    
                    // Добавляем кольца на платформы и над промежутками
                    createRing(0, 1.5, -5);
                    createRing(0, 1.5, -10);
                    createRing(0, 2.0, -13.5); // Над первым промежутком
                    createRing(0, 1.5, -20);
                    createRing(2.5, 1.5, -25);
                    createRing(5, 2.0, -26.5); // Над вторым промежутком
                    createRing(5, 1.5, -35);
                    createRing(2.5, 2.0, -40); // Над третьим промежутком
                    createRing(0, 1.5, -50);
                    createRing(0, 1.5, -55);
                    
                    // Переменные для управления
                    let forwardSpeed = -0.2;  // Скорость вперёд (отрицательная по Z)
                    let isJumping = false;
                    let horizontalMovement = 0;
                    
                    // Обработка клавиш для ПК
                    const keyDown = (evt) => {
                        if (evt.keyCode === 32) { // Пробел
                            jump();
                        } else if (evt.keyCode === 37) { // Стрелка влево
                            horizontalMovement = -0.2;
                        } else if (evt.keyCode === 39) { // Стрелка вправо
                            horizontalMovement = 0.2;
                        }
                    };
                    
                    const keyUp = (evt) => {
                        if (evt.keyCode === 37 && horizontalMovement < 0) {
                            horizontalMovement = 0;
                        } else if (evt.keyCode === 39 && horizontalMovement > 0) {
                            horizontalMovement = 0;
                        }
                    };
                    
                    // Функция для нахождения ближайшей платформы впереди
                    const findNextPlatform = function() {
                        let closestDistance = Infinity;
                        let closestPlatform = null;
                        
                        for (const rail of rails) {
                            // Проверяем только платформы впереди игрока
                            if (rail.position.z < ball.position.z) {
                                // Вычисляем расстояние до платформы
                                const dist = BABYLON.Vector3.Distance(ball.position, rail.position);
                                
                                // Если это ближайшая платформа спереди, запоминаем ее
                                if (dist < closestDistance) {
                                    closestDistance = dist;
                                    closestPlatform = rail;
                                }
                            }
                        }
                        
                        return { platform: closestPlatform, distance: closestDistance };
                    };
                    
                    // Функция прыжка с проверкой расстояния до следующей платформы
                    const jump = function() {
                        // Проверяем, что мяч на земле (не в прыжке)
                        const raycast = new BABYLON.Ray(ball.position, new BABYLON.Vector3(0, -1, 0), 1.5);
                        const hit = scene.pickWithRay(raycast);
                        
                        if (hit.hit && !isJumping) {
                            isJumping = true;
                            
                            // Находим следующую платформу и расстояние до нее
                            const nextPlatform = findNextPlatform();
                            
                            // Базовая сила прыжка
                            let jumpForce = 9.0;
                            
                            // Если есть платформа впереди, корректируем силу прыжка
                            if (nextPlatform.platform && nextPlatform.distance < 15) {
                                // Увеличиваем силу прыжка в зависимости от расстояния
                                jumpForce = Math.max(jumpForce, 9.0 + nextPlatform.distance * 0.2);
                                console.log("Прыжок с силой: " + jumpForce + " на расстояние: " + nextPlatform.distance);
                            }
                            
                            // Применяем импульс для прыжка
                            ball.physicsImpostor.applyImpulse(
                                new BABYLON.Vector3(0, jumpForce, 0), 
                                ball.getAbsolutePosition()
                            );
                            
                            setTimeout(() => { isJumping = false; }, 1000);
                        }
                    };
                    
                    // Настройка обработчиков для ПК
                    window.addEventListener("keydown", keyDown);
                    window.addEventListener("keyup", keyUp);
                    
                    // Настройка сенсорных элементов управления для мобильных устройств
                    if (isMobile) {
                        const leftBtn = document.getElementById('leftBtn');
                        const rightBtn = document.getElementById('rightBtn');
                        const jumpBtn = document.getElementById('jumpBtn');
                        
                        // Функции для сенсорного управления
                        let isTouchingLeft = false;
                        let isTouchingRight = false;
                        
                        // Обработка кнопки влево
                        leftBtn.addEventListener('touchstart', function(e) {
                            e.preventDefault();
                            isTouchingLeft = true;
                            horizontalMovement = 0.2;
                            leftBtn.classList.add('active');
                        }, {passive: false});
                        
                        leftBtn.addEventListener('touchend', function(e) {
                            e.preventDefault();
                            isTouchingLeft = false;
                            if (!isTouchingRight) horizontalMovement = 0;
                            leftBtn.classList.remove('active');
                        }, {passive: false});
                        
                        // Обработка кнопки вправо
                        rightBtn.addEventListener('touchstart', function(e) {
                            e.preventDefault();
                            isTouchingRight = true;
                            horizontalMovement = -0.2;
                            rightBtn.classList.add('active');
                        }, {passive: false});
                        
                        rightBtn.addEventListener('touchend', function(e) {
                            e.preventDefault();
                            isTouchingRight = false;
                            if (!isTouchingLeft) horizontalMovement = 0;
                            rightBtn.classList.remove('active');
                        }, {passive: false});
                        
                        // Обработка кнопки прыжка
                        jumpBtn.addEventListener('touchstart', function(e) {
                            e.preventDefault();
                            jump();
                            jumpBtn.classList.add('active');
                            setTimeout(() => jumpBtn.classList.remove('active'), 200);
                        }, {passive: false});
                    }
                    
                    // Функция для проверки сбора колец
                    const checkRingCollection = function() {
                        for (let i = rings.length - 1; i >= 0; i--) {
                            const ring = rings[i];
                            const distance = BABYLON.Vector3.Distance(ball.position, ring.position);
                            
                            // Если мяч коснулся кольца
                            if (distance < 1.5) {
                                // Увеличиваем счет
                                score += 10;
                                document.getElementById('scoreDisplay').textContent = "Счет: " + score;
                                
                                // Удаляем кольцо
                                ring.dispose();
                                rings.splice(i, 1);
                            }
                        }
                    };
                    
                    // Обновление игры на каждом кадре
                    scene.registerBeforeRender(function() {
                        // Движение мяча вперед автоматически и по горизонтали
                        const currentVelocity = ball.physicsImpostor.getLinearVelocity();
                        ball.physicsImpostor.setLinearVelocity(
                            new BABYLON.Vector3(
                                horizontalMovement * 10, 
                                currentVelocity.y, 
                                forwardSpeed * 15
                            )
                        );
                        
                        // Вращение мяча при движении
                        ball.rotate(BABYLON.Vector3.Right(), -forwardSpeed * 0.2);
                        
                        // Обновление позиции камеры - следование за мячом
                        camera.position.x = ball.position.x;
                        camera.position.y = ball.position.y + 5;
                        camera.position.z = ball.position.z + 10;
                        
                        // Камера смотрит на мяч
                        camera.setTarget(ball.position);
                        
                        // Проверка сбора колец
                        checkRingCollection();
                        
                        // Анимация вращения колец
                        for (const ring of rings) {
                            ring.rotation.y += 0.02;
                        }
                        
                        // Проверка падения в пропасть
                        if (ball.position.y < -10) {
                            ball.position = new BABYLON.Vector3(0, 5, 0);
                            ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                            
                            // Сброс счета при падении
                            score = Math.max(0, score - 50);
                            document.getElementById('scoreDisplay').textContent = "Счет: " + score;
                        }
                    });
                    
                    return scene;
                };
                
                // Создаем сцену
                const scene = createScene();
                
                // Скрываем экран загрузки когда сцена готова
                scene.executeWhenReady(function() {
                    document.getElementById('loadingScreen').style.display = 'none';
                });
                
                // Запускаем рендеринг
                engine.runRenderLoop(function() {
                    scene.render();
                });
                
                // Обработка изменения размера окна
                window.addEventListener('resize', function() {
                    engine.resize();
                });
                
            } catch (error) {
                showError("Ошибка: " + error.message);
                console.error(error);
            }
        });
    </script>
</body>
</html>
